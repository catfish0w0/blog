---
# multilingual page pair id, this must pair with translations of this page. (This name must be unique)
lng_pair: basc_java_3
title: How to Generate Random Numbers in Java and Implement Reservoir Sampling Algorithm

# post specific
# if not specified, .name will be used from _data/owner/[language].yml
author: Puff
# multiple category is not supported
category: Java Basic
# multiple tag entries are possible
tags: [Java]
# thumbnail image for post
img: ":java_basic/randomness/randomness.PNG"
# disable comments on this page
#comments_disable: true

# publish date
date: 2023-07-31 23:16:06 +0900
# seo
# if not specified, date will be used.
#meta_modify_date: 2022-02-10 08:11:06 +0900
# check the meta_common_description in _data/owner/[language].yml
#meta_description: ""

# optional
# please use the "image_viewer_on" below to enable image viewer for individual pages or posts (_posts/ or [language]/_posts folders).
# image viewer can be enabled or disabled for all posts using the "image_viewer_posts: true" setting in _data/conf/main.yml.
#image_viewer_on: true
# please use the "image_lazy_loader_on" below to enable image lazy loader for individual pages or posts (_posts/ or [language]/_posts folders).
# image lazy loader can be enabled or disabled for all posts using the "image_lazy_loader_posts: true" setting in _data/conf/main.yml.
#image_lazy_loader_on: true
# exclude from on site search
#on_site_search_exclude: true
# exclude from search engines
#search_engine_exclude: true
# to disable this page, simply set published: false or delete this file
#published: false
---

<!-- outline-start -->

<!-- outline-end -->

Before delving into the reservoir sampling algorithm, let's first understand some basic Java concepts related to random number generation. Having this knowledge will be really helpful before diving into the algorithm. Java offers two common methods to generate random objects: using a <span style="color:red">**pseudo-random generator**</span> and utilizing the <span style="color:red">**Math.random()**</span> method.

Java provides the _java.util.Random_ library and the _java.lang.Math_ class for generating random numbers. The former method involves creating a Random instance to generate random numbers, while the latter utilizes the Math.random() method, which generates a double value from 0 (inclusive) to 1 (exclusive).

#### Understanding the Random Library in Java

The Math.random() method is a static method provided by the Math library. It returns a double value ranging from 0 (inclusive) to 1 (exclusive) without requiring any input parameters. On the other hand, to use the Random generator, you need to create a Random instance before calling its methods. Consequently, you'll often see developers creating a Random object for random number generation.

Looking into the source code, you'll find that the underlying logic of Math.random() also involves creating a Random generator and calling the random.nextDouble() method to produce the random number. Therefore, in this blog, we will focus on generating random values using the Random objects.

#### Inside the Random Object Library

The **Random** object library provides two constructor methods. The first is the default constructor, while the second one allows you to provide an input seed. A seed is a value used to generate a random sequence. It's essential to note that if two Random generators have the same seed, all the random values generated by them will be identical.

The default constructor of the Random class employs the system's nanosecond value to generate the seed. Consequently, the random seed is generated based on the JVM's running time.

Here is the example:

```java
public static void main(String[] args) {
    Random random1 = new Random(10);
    System.out.println("Here is using one random object:");
    for (int i = 0; i < 10; i++) {
        System.out.print(random1.nextInt(10) + " ");
    }

    System.out.println();
    Random random2 = new Random(10);
    System.out.println("Here is using another random object:");
    for (int i = 0; i < 10; i++) {
        System.out.print(random2.nextInt(10) + " ");
    }
}
/*
Result:
    Here is using one random object:
    3 0 3 0 6 6 7 8 1 4
    Here is using another random object:
    3 0 3 0 6 6 7 8 1 4
*/
```

In many interview and coding challenges, it will most likely ask to generate random numbers within a specified range [a, b]. Here's a simple approach to create both a random integer and a random double within this range using the random generator method in Java:

```java
public static void main(String[] args) {
    int a = 1; // Replace 'a' with the desired lower bound of the range
    int b = 10; // Replace 'b' with the desired upper bound of the range

    // Generate a new pseudo-random generator
    Random random = new Random();

    // Generate a random integer in the range [a, b]
    int randomInt = random.nextInt(b - a + 1) + a; // Produces a random number from [a, b]

    // Generate a random double in the range [a, b)
    double randomDouble = Math.random() * (b - a) + a; // Produces a random number from [a, b)

    System.out.println("Random Integer: " + randomInt);
    System.out.println("Random Double: " + randomDouble);
}
```

#### Intro to randomness and probability

Consider the seemingly straightforward task of generating a random element from an array. It appears rather simple, doesn't it? By generating a random index within the range of 0 to array.length - 1, we can subsequently retrieve the element corresponding to that index.

However, a challenge emerges when the goal is to generate an array with elements arranged in a random order, ensuring that **each element is equally likely to appear at any position within the array**, also known as perfect shuffling.

One approach to solving this involves a rather brute-force(DFS Backtracking) method, explores all possible solutions by **generating all permutations** of the array. Once these permutations are generated, a single solution can be randomly selected from among them. Essentially, this question boils down to finding a single path within all permutations.

TC: O(n!)&emsp;SC: O(1)

A more efficient approach then comes into play after grasping the concepts above. If our aim is to find only one randomly selected path within the recursion tree, we can streamline the process by focusing on two key aspects. First, it's important to **randomly select an index for swapping** in each iteration/recursion. Second, to **ensure that previously swapped elements are not swapped again**.

To model this approach, we traverse the array in reverse order. During each iteration, we randomly select an element from the range of 0 to the current index i and swap it with the last element in the array. The index i then acts as a boundary, defining the scope within which elements are considered for swapping.

TC: O(n)&emsp;SC: O(1)

Code:

```java
public void shuffle(int[] array) {
    Random random = new Random();
    for (int i = array.length; i >= 1; i--) {
      int index = random.nextInt(i);
      swap(array, i - 1, index);
    }
}
private void swap(int[] array, int i, int j) {
    int temp = array[i];
    array[i] = array[j];
    array[j] = temp;
}
```

#### Intro to Reservoir Sampling

The above approach allows us to open new way to dealt with randomess problem. It still has several limitation. First of all, it can only dealt with fixed size sample. Secondly, it cannot run in offline manner, we have to get full sample size before finding randomess within elements. In reality, this is rather inefficient and memory-consuming. Therefore, people invented another simple yet elegant algorithm to solve probability problems, reservoir sampling.

The problem becomes as follow: Consider an unlimited flow of data elements. How do you sample one element from this flow, such that at any point during the processing of the flow, you can return a random element from the n elements read so far. Implement two methods for a sampling class: read(int value) - read one number from the flow, sample() return a sample that we have seen so far.

| data | size | propability to select new element | probability for previous selected element to stay |
| -- | -- | :-------------------------------" | :-----------------------------------------------: |
| [1] | 1 | 1/1 | N/A |
| [1, 2] | 2 | 1/2 | 1/2 |
| [1, 2, 3] | 3 | 1/3 | 1/2 multuply 2/3(not select) = 1/3 |

#### Practice Questions

| Problem Number |                        Problem                        |                                               Solution                                                |
| :------------: | :---------------------------------------------------: | :---------------------------------------------------------------------------------------------------: |
|       1        | [High Five](https://leetcode.com/problems/high-five/) | ![](https://docs.google.com/document/d/1UFcQUbRZRQLSstLyUknyV64j2rGflt3JZzaD8GRhdKI/edit?usp=sharing) |

Some of the questions are not from leetcode, so I create a google doc with the problem describtion and some examples.
